# 함수
 - 특정 작업을 수행하기 위한 재사용 가능한 코드 묶음

![image](https://github.com/ragu6963/TIL/assets/32388270/fe4bb4a9-f88d-43f8-9e6e-915e3c790b48)

## 함수의 구조와 호출
### 함수의 정의
- def 키워드로 시작하여 함수 이름 작성
- 괄호 안에 매개변수 정의

### 함수 body
- 함수가 실행될 때 수행되는 코드 정의
- `Docstring`: 주석으로 선택적으로 작성 가능한 함수 설명서
- 함수 반환 값
    - return 키워드 이후에 반환할 값을 명시
    - return 문은 함수의 실행을 종료하고 결과를 호출 부분으로 반환
    - return은 필수는 아니지만 작성하지 않았을 경우 None을 자동적으로 return한다.
        - 함수가 종료되기 위해서는 무조건 return 값이 필요하기 때문에 파이썬이 자동으로 return하는 것이다.
    > print도 일종의 함수인데 print는 return 값이 없는 함수이다.
    >
    > print는 단순히 출력을 하는 것이지 어떤 값을 반환 하는 것이 아니다.
    >
    > return과 출력은 다른 개념이다.

### 함수 호출
- 함수를 사용하기 위해 필요
- 함수의 이름과 소괄호를 활용하며 소괄호 내에 인자를 전달
    - 인자는 매개변수에 대입되어 계산

# 매개변수와 인자

## 매개변수
 - 함수를 정의할 때 함수가 받을 값을 나타내는 변수
 - 매개변수는 단순히 인자의 위치를 알려주는 역할로 어떤 문자를 사용하든 크게 중요하지 않다.

```python
def add_numbers(x, y): # x, y는 매개변수
    result=x+y
    return result

a=2
b=3
sum_result=add_numbers(a, b) # a, b는 인자
print(sum_result)
```

## 인자
 - 함수를 호출할 때, 실제로 전달되는 값

 ### 위치 인자
  - 함수 호출 시 인자의 위치에 따라 전달되는 인자
  - 위치 인자는 함수 호출 시 반드시 값을 전달해야 한다.
  ```python
  def greet(name, age):
    print(f'안녕하세요, {name}님! {age}살이시군요.')

  greet('Alice', 25) # 안녕하세요, Alice님! 25살이시군요.
  greet('Alice') # 에러 발생
  greet (25, 'Alice') # 안녕하세요, 25님! Alice살이시군요.
  ```

 ### 기본 인자 값
  - 함수 정의에서 매개변수에 기본 값을 할당하는 것
  - 함수 호출 시 인자를 전달하지 않으면 기본값이 매개변수에 할당된다.
  - 인자 전달을 통해 내가 원하는 값을 할당하는 것도 가능하다.
  ```python
  def greet(name, age=20):
    print(f'안녕하세요, {name}님! {age}살이시군요.')

  greet('Bob') # 안녕하세요, Bob님! 20살이시군요.
  greet('Bob', 25) # 안녕하세요, Bob님! 25살이시군요.
  ```
 
 ### 키워드 인자
  - 함수 호출 시 인자의 이름과 함께 값을 전달하는 인자
  - 매개변수와 인자를 일치시키지 않아도 인자의 이름을 통해 원하는 매개변수에 값을 할당할 수 있다.
    - 물론 당연히 앞에서 선언한 매개변수로 인자의 이름을 지정하긴 해야한다.
  - **키워드 인자와 위치 인자를 동시에 호출할 때는 반드시 키워드 인자가 위치 인자 뒤에 위치해야 한다.**
    - 파이썬의 논리 구조상 키워드 인자가 위치 인자 앞에 위치할 경우 파이썬이 인식하지 못하게 된다.
  ```python
  def greet(name, age):
    print(f'안녕하세요, {name}님! {age}살이시군요.')

  greet(name='Dave', age=30) # 안녕하세요, Dave님! 30살이시군요.
  greet(age=30, name='Dave') # 안녕하세요, Dave님! 30살이시군요.
  greet(age=30, 'Dave') # positional argument follows keyword argument
  ```

 ### 임의의 인자 목록
  - 정해지지 않은 개수의 인자를 처리하는 인자
  - 함수 정의 시 매개변수 앞에 '*'를 붙여 사용하며 여러 개의 인자를 `tuple`로 처리한다.
  ```python
  def calculate_sum(*args):
    print(args)
    total=sum(args)
    print(f'합계: {total}')

  calculate_sum(1, 2, 3)

  # (1, 2, 3)
  # 합계: 6
  ```

 ### 임의의 키워드 인자 목록
  - 정해지지 않은 개수의 키워드 인자를 처리하는 인자
  - 함수 정의 시 매개변수 앞에 '**'를 붙여 사용하며 여러 개의 인자를 dictionary로 묶어 처리한다.
  ```python
  def print_info(**kwargs):
    print(kwargs)

  print_info(name='Eve', age=30) # {'name':'Eve', 'age':30}
  ```
 
 > 서로 다른 함수 인자를 작성할 때는 **`위치 -> 기본 -> 가변 -> 가변 키워드`** 의 순으로 작성한다.
 > 
 > 혼란을 줄이기 위한 과정이지만 상황에 따라 유연하게 조정될 수는 있다.
 > 
 > 그러나 위치 인자 뒤에 키워드 인자를 적어야 한다는 것은 항상 지킬 것.

# 재귀 함수
 - 함수 내부에서 자기 자신을 호출하는 함수

```python
def factorial(n):
    # 종료 조건: n이 0이면 1을 반환
    if n == 0:
        return 1
    else:
        # 재귀 호출: n과 n-1의 팩토리얼을 곱한 결과를 반환
        return n * factorial(n - 1)


# 팩토리얼 계산 예시
print(factorial(5))  # 120
```
### 재귀함수에서 꼭 지켜야할 점
1. 종료조건을 확실히 설정한다.
2. 반복되는 호출이 종료 조건을 향하도록 설정한다.

# 내장 함수
 - 파이썬이 기본적으로 제공하여 별도의 import 없이 바로 사용 가능한 함수
 - [python document](https://docs.python.org/ko/3.9/library/functions.html)에서 다양한 내장 함수의 종류를 알아볼 수 있다.

## 유용한 내장 함수 - map
 - `map(function, iterable)`
    - 순회 가능한 데이터구조(iterable)의 모든 요소에 함수(function)을 적용하고 그 결과를 map object로 반환
        - 결과로 나온 map object는 list로 변환시키면 원하는 결과가 나온다.
    - 요소 하나하나에 원하는 함수를 적용시키는 함수이다.
    - 반복문이 없음에도 불구하고 반복시키는 성질을 가져 굉장히 유용하게 쓰일 수 있다.
    - `function` 자리에는 내가 원하는 함수를 아무거나 집어넣어서 실행시킬 수 있기 때문에 확장성이 어마어마하다.
    - map 자체가 요소 하나하나에 함수를 적용시키는 것이기 때문에 순회 가능한 데이터구조가 `iterable`에 들어가야 한다.
```python
numbers = [1, 2, 3]
result = map(str, numbers)

print(result)  # <map object at 0x00000239C915D760>
print(list(result))  # ['1', '2', '3']
```

## 유용한 내장 함수 - zip
 - `zip(*iterables)`
    - 임의의 iterable을 모아 튜플을 원소로 하는 zip object를 반환
    - map이 순회 가능한 데이터구조의 요소들 모두에 함수를 적용시킨다면 zip은 단순히 새롭게 grouping을 하는 함수이다.
    - 서로 다른 리스트의 같은 인덱스 요소들을 한 번에 tuple로 묶어서 분류한다.
        - 여러 개의 리스트를 동시에 조회하거나 2차원 리스트의 칼럼(열) 요소를 동시에 조회할 때 주로 사용한다.
```python
scores = [
    [10, 20, 30],
    [40, 50, 39],
    [20, 40, 50],
]
for score in zip(*scores):
    print(score)

# (10, 40, 20)
# (20, 50, 40)
# (30, 39, 50)
```

# Scope
 - 파이썬의 범위
 - 함수는 코드 내부에 `local scope`를 생성하며 그 외의 공간을 `global scope`로 구분한다.
    - global scope: 코드 어디에서든 참조할 수 있는 공간
        - 여기서 정의된 변수를 global variable이라고 한다.
    - local scope: 함수가 만든 scope로 함수 내부에서만 참조할 수 있는 공간
        - 여기서 정의된 변수를 local variable이라고 한다.

 - `변수의 수명주기`때문에 local scope에서 정의한 변수는 global scope에서 사용할 수 없다.

## 변수의 수명 주기
1. built-in scope: 파이썬이 실행된 이후부터 영원히 유지
2. global scope: 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
3. local scope: 함수가 호출될 때 생성되고 함수가 종료될 때까지 유지

## LEGB Rule
 - 파이썬이 변수를 찾을 때는 아래와 같은 특정한 공간 순서로 찾는다.
    1. Local scope: 지역 범위(현재 작업 중인 범위)
    2. Enclosed scope: 지역 범위 한 단계 위 범위(함수 안에 함수를 선언했을 때 존재하는 중간 범위)
    3. Global scope: 최상단에 위치한 범위
    4. Built-in scope: 정의하지 않고 사용할 수 있는 모든 것을 담고 있는 범위
    ![image](/TIL/scope.PNG)
 - 함수 내에서는 바깥 scope의 변수에 **접근은 가능하나 수정은 할 수 없다**.

 ```python
 print(sum)
 print(sum(range(3))) # 3

 sum =5

 print(sum)
 print(sum(range(3))) # 에러 발생
 ```
 위에서 sum은 이미 built-in scope에 내장함수로 저장이 되어 있다. 이 sum을 global scope에서 다른 변수로 정의를 하고 내장함수 sum을 사용하려면 불가하다. 파이썬은 안쪽에서 바깥쪽으로 변수를 찾아나가고 global scope에서 이미 변수로 정의된 sum을 찾아 버리기 때문에 built-in scope까지 가지 않는다. 즉 내장함수의 sum을 사용할 수 없게 되는 것이다.

### LEGB 예시 문제 (어려움)
```python
a = 1
b = 2


def enclosed():
    a = 10
    c = 3

    def local(c):
        print(a, b, c)  # 10 2 500

    local(500)
    print(a, b, c)  # 10 2 3


enclosed()

print(a, b)  # 1 2
```
#### 해설
1. 함수 내에 있는 매개변수는 의미가 없고 함수가 호출될 때 인자가 실제 변수로 작용하기 때문에 처음 c는 500. 출력은 10 2 500
2. 그 다음 print를 할 때는 변수 a를 local area에서 찾을 수 없기 때문에 enclosed area로 넘어가기. 그 후 변수 b를 global area에서 찾기. c는 현재 위치하고 있는 local area에서 찾을 수 있기 때문에 3. 출력은 10 2 3
3. 마지막은 처음부터 global area에서부터 찾기. 출력은 1 2
> 파이썬이 변수를 찾기 시작하는 범위는 해당 코드가 포함되어 있는 범위라고 생각을 하면 편하다. 마지막의 a, b는 정의되어 있는 함수와 아무 관련이 없는 코드기 때문에 바로 global area에서 찾는 것이다.

## Global 키워드
 - 변수의 스코프를 전역 범위로 지정하기 위해 사용
 - 일반적으로 함수 내에서 전역 변수를 수정하려는 경우에 사용
 - **매개변수에는 global 키워드를 사용할 수 없다.**

# Packing & Unpacking

## Packing
 - 여러 개의 값을 하나의 변수에 묶어서 담는 것
 - 변수에 담긴 값들은 `튜플` 형태로 묶인다.
 ```python
 packed_values = 1, 2, 3, 4, 5
 print(packed_values)  # (1, 2, 3, 4, 5)
 ```

### '*'를 활용한 packing
 - 남는 요소들을 `리스트`로 패킹하여 할당
```python
numbers = [1, 2, 3, 4, 5]
a, *b, c = numbers
print(a)  # 1
print(b)  # [2, 3, 4]
print(c)  # 5
```

## Unpacking
 - 튜플이나 리스트 등의 객체의 요소들을 개별 변수에 할당
```python
packed_values = 1, 2, 3, 4, 5

a, b, c, d, e = packed_values
print(a, b, c, d, e)  # 1 2 3 4 5
```

### '*'를 활용한 언패킹
 - 리스트의 요소를 언패킹하여 인자로 전달
 ```python
 def my_function(x, y, z):
    print(x, y, z)


 names = ['alice', 'jane', 'peter']
 my_function(*names)  # alice jane peter
 ```

### '**'를 활용한 언패킹
 - 딕셔너리의 키-값 쌍을 언패킹하여 함수의 키워드 인자로 전달
 - 키에 해당하는 값을 키워드 인자로 전달한다.
 ```python
 def my_function(x, y, z):
    print(x, y, z)


 my_dict = {'x': 1, 'y': 2, 'z': 3}
 my_function(**my_dict)  # 1 2 3
 ```

> '*'는 패킹, 언패킹 연산자로 모두 사용될 수 있고 '**'는 언패킹 연산자로만 사용 가능하다.

# 람다 표현식
 - 익명 함수를 만드는데 사용되는 표현식
 - 한줄로 간단한 함수를 정의할 때 사용된다.
 - `lambda 매개변수: 표현식`
    - 여러 개의 매개변수가 있을 경우 쉼표로 구분
 - map 함수 안에 함수를 지정할 때 lambda를 사용하여 표현하면 간단하다.
```python
def square(x):
    return x**2


# lambda 미사용
squared1 = list(map(square, numbers))
print(squared1)  # [1, 4, 9, 16, 25]

# lambda 사용
squared2 = list(map(lambda x:x**2, numbers))
print(squared2)
```
