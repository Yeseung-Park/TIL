# 백트래킹 (이어서)

## 백트래킹을 이용한 부분집합 문제 풀기
- 부분집합을 만드는 방법은 비트 연산자를 이용해서 앞에서 설명한 적이 있다.
- 이번에는 재귀함수를 이용해서 부분집합을 만들어보겠다.

### 부분집합 만드는 코드
```python
# 부분집합 만들기

def f(i, k):    # bit[i]를 결정하는 함수
    if i == k:    # 모든 원소에 대해서 결정하면
        for j in range(k):
            if bit[j]:    # bit[j]가 1이라면 부분집합에 포함한다는 것이므로
                print(a[j], end = ' ')    # 해당 원소를 출력
        print()
    else:
        for j in [1, 0]:
            bit[i] = j
            f(i+1, k)


N = 3
a = [1, 2, 3]    # 주어진 원소의 집합
bit = [0]*N    # 원소의 포함여부를 표시하는 배열

f(0, N)    # N개의 원소에 대해 부분집합을 만드는 함수
```

### 연습문제 풀이
- {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}의 부분집합 중 원소의 합이 10인 부분집합의 개수를 구하시오.

#### 코드
```python
# 부분집합 연습문제2

def f(i, k, s, t):    # i: 원소, k: 집합의 크기, s: i-1까지 고려된 합, t: 목표 합 값
    global cnt
    # 이 부분이 백트래킹이다. 모든 집합을 우선 만든 다음 그 안에서 고려하는 것이 아니라 부분집합을 하나씩 만들어가면서 합을 그때마다 구하고 조건에 맞으면 고려하는 것. 근데 결국 모든 부분집합을 보긴 해야하니까 백트래킹 안 했을 때랑 크게 차이가 있나....?
    if s > t:    # 고려한 원소의 합이 찾는 합보다 큰 경우
        return
    elif s == t:    # 고려한 원소의 합이 찾는 합일 경우
        cnt += 1
        return
    elif i == k:    # 모든 원소를 돌았을 경우
        return    # return을 함으로써 다른 부분집합을 만들 수 있도록 이전에 호출했던 함수로 되돌아간다.
    else:    # 그 외의 경우 (모든 원소를 돌지도 않고 원소의 합이 찾는 합보다 작은 경우)
        bit[i] = 1    # 부분집합 만들기
        f(i+1, k, s+A[i], t)    # A[i] 포함    # 해당 부분집합의 합을 다시 넣어서 돌리기
        bit[i] = 0
        f(i+1, k, s, t)    # A[i] 미포함

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
N = 10

key = 10    # 찾고자 하는 합
cnt = 0    # 합을 만족하는 부분집합의 개수를 세는 변수
bit = [0]*N    # bit 집합
f(0, N, 0, key)    # 함수 돌리기
print(cnt)
```
이게 분명 이해는 되긴 하는데 설명하기 너무 어렵다.
어쨌든 단순한 집합에 대한 부분집합을 생각하려고 해도 함수 호출이 엄청 여러번 되기 때문에... 직접 그려보다가 죽는 줄 알았다.

## 재귀를 이용한 순열 만들기
- 사실 순열 만드는 과정에는 백트래킹이 들어가는지 아닌지 모르겠다.
    - 안 들어간다.

```python
# 순열 만들기

def f(i, N):
    global count
    if i == N:
        print(P)
    else:
        for j in range(i, N):
            P[i], P[j] = P[j], P[i]
            f(i+1, N)
            P[i], P[j] = P[j], P[i]

N = 4
P = [1, 2, 3, 4]
f(0, N)
```