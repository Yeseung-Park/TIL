# 상속
- 기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것
- 코드 재사용을 통한 중복된 코드 줄이기
- 계층 구조 형성을 통한 더 구체적인 클래스 생성
- 유지 보수의 용이성 증가

## 클래스 상속
- 상속을 사용하면 다양한 클래스를 별도로 표현하면서도 공통된 사항에 대해 중복 없이 표현할 수 있어 유용하다.
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):  # 메서드 재사용
        print(f'반갑습니다. {self.name}입니다.')


class Professor(Person):  # Person 클래스 상속
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department


class Student(Person):  # Person 클래스 상속
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa


p1 = Professor('박교수', 49, '컴퓨터공학과')
s1 = Student('김학생', 20, 3.5)

# 부모 Person 클래스의 talk 메서드를 활용
p1.talk()  # 반갑습니다. 박교수입니다.

# 부모 Person 클래스의 talk 메서드를 활용
s1.talk()  # 반갑습니다. 김학생입니다.
```

## 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
- 중복된 속성이나 메서드가 있는 경우 **상속 순서**에 의해 결정된다.
    - 상속 순서는 상속받을 때 먼저 쓴 클래스가 우선 순위이다.
```python
class Person:
    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'


class Mom(Person):
    gene = 'XX'

    def swim(self):
        return '엄마가 수영'


class Dad(Person):
    gene = 'XY'

    def walk(self):
        return '아빠가 걷기'


class FirstChild(Dad, Mom):
    def __init__(self, name, age, address):
        Dad.__init__()
        

    def swim(self):
        return '첫째가 수영'

    def cry(self):
        return '첫째가 응애'


baby1 = FirstChild('아가')
print(baby1.cry())  # 첫째가 응애
print(baby1.swim())  # 첫째가 수영
print(baby1.walk())  # 아빠가 걷기
print(baby1.gene)  # XY
```
위에서 FirstChild는 Dad와 Mom을 상속받았으므로 둘의 메서드와 변수를 다 쓸 수 있다. 따라서 `baby1.walk()`에 대한 결과로 `아빠가 걷기`가 나온 것이다.

그러나 `baby1.gene`의 경우 Dad 클래스에도 존재하고 Mom 클래스에도 존재하는데 어떤 클래스의 변수를 써야 할까? 그것은 상속 순서에 의해서 결정된다. FirstChild 클래스를 선언할 때 Dad를 먼저 썼으므로 Dad 클래스를 우선적으로 탐색하게 된다. 따라서 `baby1.gene`에 대한 결과로 Dad 클래스의 변수 값인 `XY`가 나온 것이다.


이처럼 어떤 클래스가 두 개 이상의 클래스에 대해 다중 상속이 일어났을 때 공통된 메서드나 변수에 대해서 어떤 클래스의 것을 상속할 것이냐에 대한 문제를 **다이아몬드 문제(The diamond problem)** 라고 한다.

### MRO (Method Resolution Order)
- 메서드 결정 순서
- 다이아몬드 문제를 해결하기 위하여 파이썬이 사용하는 알고리즘
- 부모 클래스로부터 상속된 속성들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로 행한다.
- 계층 구조에서 겹치는 같은 클래스는 두 번 검색하지 않는다.

#### MRO() 메서드
- 해당 인스턴스의 클래스가 어떤 부모 클래스를 가지는지 확인하는 메서드
- 탐색 순서대로 클래스를 보여준다.
```python
class A:
    def __init__(self):
        print('A Constructor')


class B(A):
    def __init__(self):
        super().__init__()
        print('B Constructor')


class C(A):
    def __init__(self):
        super().__init__()
        print('C Constructor')


class D(B, C):
    def __init__(self):
        super().__init__()
        print('D Constructor')


print(D.mro()) 
# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

### super()
- 부모 클래스 객체를 반환하는 내장 함수
- 다중 상속시 MRO를 기반으로 현재 클래스가 상속하는 모든 부모 클래스 중 다음에 호출될 메서드를 결정하여 자동으로 호출
- 다중 상속을 할 때는 부모 클래스의 탐색 순서가 굉장히 중요하고 이를 고려해서 코드를 써줘야 하는데 코드가 복잡해지고 상속 관계가 복잡해지면 이를 매번 찾아주기가 어렵기 때문에 `super()`를 사용한다
    - 다중 상속이 아닌 단순 클래스 상속일 경우에도 부모 클래스 이름 변경이나 교체 시 코드 수정을 더 적게 해주기 위해 `super()`를 사용해주는 것이 좋다.

```python
class ParentA:
    def __init__(self):
        self.value_a = 'ParentA'

    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')


class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')


class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__()  # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'


child1 = Child()
print(child1.value_a)  # ParentA 클래스의 value_a 호출
print(child1.value_c)  # Child
print(child1.value_b)  # AttributeError: 'Child' object has no attribute 'value_b'
```

> super()는 MRO를 기준으로 상위 클래스를 가져온다. 만약 내가 MRO 순서에 맞지 않게 특정 부모 클래스를 호출하고 싶다면 super()는 쓰지 않고 직접 호출해야 한다. 그러나 이러한 상황은 최대한 만들지 않는 것이 좋다.

# 에러와 예외

## 버그
- 소프트웨어에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치

## 디버깅
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업

## 에러
- 프로그램 실행 중에 발생하는 예외 상황

### 문법 에러 (Syntax Error)
- 프로그램의 구문이 올바르지 않은 경우 발생
- 오타, 괄호 및 콜론 누락 등의 문법적 오류

#### invalid syntax (문법 오류)
```python
while  # SyntaxError: invalid syntax
```

#### assign to literal (잘못된 할당)
```python
5=3  # SyntaxError: cannot assign to literal
```

#### EOL (End of Line)
```python
print('hello
# SyntaxError: EOL while scanning string literal
```

#### EOF (End of File)
```python
print(
# SyntaxError: unexpected EOF while parsing
```

### 예외 (Exception)
- 프로그램 실행 중에 감지되는 에러
- **내장 예외**: 예외 상황을 나타내는 예외 클래스들
    - 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용

#### ZeroDivisionError
- 나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생
```python
10/0  # ZeroDivisionError: division by zero
```

#### NameError
- 지역 또는 전역 이름을 찾을 수 없을 때 발생
```python
print(name_error)  # NameError: name 'name_error' is not defined
```

#### TypeError
- 타입 불일치
```python
'2' + 2  # TypeError: can only concatenate str (not "int") to str
```
- 인자 누락
```python
sum()  # TypeError: sum() takes at least 1 positional argument (0 given)
```
- 인자 초과
```python
sum(1, 2, 3)  # TypeError: sum() takes at most 2 arguments (3 given)
```
- 인자 타입 불일치
```python
import random
random.sample(1, 2)  # TypeError: Population must be a sequence.  For dicts or sets, use sorted(d).
```

#### ValueError
- 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 IndexError처럼 더 구체적인 예외로 설명되지 않는경우
```python
int('1.5')  # ValueError: invalid literal for int() with base 10: '1.5'
range(3).index(6)  # ValueError: 6 is not in range
```

#### IndexError
- 시퀀스 인덱스가 범위를 벗어날 때 발생
```python
empty_list=[]
empty_list[2]  # IndexError: list index out of range
```

#### KeyError
- 딕셔너리에 해당 키가 존재하지 않는 경우
```python
person={'name':'Alice'}
person['age']  # KeyError: 'age'
```

#### ModuleNotFoundError
- 모듈을 찾을 수 없을 때 발생
```python
import hahaha  # ModuleNotFoundError: No module named 'hahaha'
```

#### ImportError
- import 하려는 이름을 찾을 수 없을 때 발생
```python
from random import hahaha  # ImportError: cannot import name 'hahaha' from 'random'
```

#### KeyboardInterrupt
- 사용자가 ctrl-c 또는 del을 누를 때 발생
```python
while True:
    continue
'''
Traceback (most recent call last):
  File "C:\Users\SSAFY\Desktop\ys_ssafy\TIL\practice.py", line 2, in <module>
    continue
KeyboardInterrupt
'''
```

#### IndentationError
- 잘못된 들여쓰기와 관련된 문법 오류
```python
for i in range(10):
print(i)  # IndentationError: expected an indented block
```

# 예외 처리
- 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법

## 사용 구문
- `try`: 예외가 발생할 수 있는 코드 작성
- `except`: 예외가 발생했을 때 실행할 코드 작성
- `else`: 예외가 발생하지 않았을 때 실행할 코드 작성
- `finally`: 예외 발생 여부와 상관 없이 항상 실행할 코드 작성
- 이들은 `if-else` 구문과 함께 사용 가능하다.

```python
try:
    x = int(input('숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except ValueError:
    print('유효한 숫자가 아닙니다.')
else:
    print(f'결과: {y}')
finally:
    print('프로그램이 종료되었습니다.')
```

> ### 주의할 점
> 
> 내장 예외 클래스는 상속 계층구조를 가지기 때문에 except 절로 분기 시 반드시 하위 클래스를 먼저 확인할 수 있도록 작성해야 한다. 그렇지 않을 경우 상위 클래스에서 모든 것이 끝나버리기 때문에 하위 클래스를 활용하는 코드가 실행이 되지 않고 원하는 결과를 얻을 수 없다.
> 
> 굳이 이 계층구조를 외울 필요가 없다. 이런 상황이 발생한다면 파이썬에서 의미 없어진 코드가 무엇인지 알려주기 때문에...

## 예외 객체
- 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
- `as`를 이용하여 예외 객체를 받아 상세한 예외 정보를 활용 가능하다.
```python
my_list = []

try:
    number = my_list[1]
except IndexError as error:
    print(f'{error}가 발생했습니다.')  # list index out of range가 발생했습니다.
```

## 예외 처리에 대한 두 가지 접근 방식

### EAFP
- Easier to Ask for Forgiveness than Permission
- 예외처리를 중심으로 코드를 작성하는 접근 방식
- `try-except`

### LBYL
- Look Before You Leap
- 값 검사를 중심으로 코드를 작성하는 접근 방식
- `if-else`