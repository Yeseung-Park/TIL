# 관통 프로젝트

# PJT 01

### 오늘 pjt 를 통해 배운 내용

- API가 무엇인지, API를 어떻게 활용하는지 알 수 있었다.

- json 형식이 무엇인지 알고 이를 적용하는 법을 알 수 있었다.

- 복잡한 데이터 구조에서 원하는 데이터를 추출하는 법을 익힐 수 있었다.


## 날씨 데이터 수집 A. 데이터 추출 - Key 값 출력하기

- 주요 요구 사항 : 날씨 데이터의 응답을 json 형태로 변환 후 Key 값만 출력하도록 구성합니다.

- 결과 : 
  $ python problem1.py
  ```
  dict_keys(['coord', 'weather', 'base', 'main', 'visibility', 'wind', 'clouds', 'dt', 'sys', 'timezone', 'id', 'name', 'cod'])
  ```
  
  - 기억해볼 부분
  
    ```python
    import requests

    def get_weather(api_key):
    city = "Seoul,KR"
    url = f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}'

    response=requests.get(url).json()
    ```
  
    - API를 이용하여 자료를 요청하고 이를 json 형태로 바꿔서 변수에 할당하는 부분
    - 앞으로 굉장히 많이 사용할 부분이라 잘 알아두면 좋을 것 같다.

  - 트러블 슈팅한 부분
  
    ```python
    result=response.keys()
    ```
  
    - 트러블이라기보다는 헤맨 부분
    - `dict.keys()`를 생각하지 못하고 for문을 사용하여 새로운 리스트에 딕셔너리의 키 값을 하나씩 직접 넣어주는 방법으로 접근했다.
    - `dict.keys()`: 딕셔너리의 키 값만을 선택하여 리스트로 만드는 함수

-----
## 날씨 데이터 수집 B. 데이터 추출 - 원하는 값만 추출하기

- 주요 요구 사항 : 날씨 데이터 중 다음 조건에 해당하는 값만 딕셔너리 형태로 반환하는 함수를 구성합니다.
  - KEY 값이 "main"인 데이터
  - KEY 값이 "weather"인 데이터

- 결과 :  $ python problem2.py
  ```
  {'main': {'feels_like': 303.07,
          'humidity': 89,  
          'pressure': 1004,
          'temp': 299.89,
          'temp_max': 299.91,
          'temp_min': 298.84},
  'weather_data': [{'description': 'moderate rain',
                   'icon': '10n',
                   'id': 501,
                   'main': 'Rain'}]}
  ```

  - 기억해볼 부분
    - 특별히 새롭게 적용한 내용은 없다.
    - 복잡한 리스트와 딕셔너리에서 데이터를 탐색하는 방법은 앞으로 많이 쓰일 것이니 확실히 익혀두자.

  - 트러블 슈팅한 부분
  
    ```python
    result1={'feels_like':response['main']['feels_like'],
             'humidity':response['main']['humidity'],
             'pressure':response['main']['pressure'],
             'temp':response['main']['temp'],
             'temp_max':response['main']['temp_max'],
             'temp_min':response['main']['temp_min']}
    result2=response['weather']
    result={'main':result1, 'weather_data':result2}
    ```
  
    - 트러블이라기보다는 헤맨 부분
    - 딕셔너리에 원하는 값만을 선택해주기 위해 'main' 딕셔너리 값 안의 딕셔너리의 키 값들을 새로운 딕셔너리로 하나씩 수동으로 배치해주었다.
      - 이보다 더 간단한 방법이 있을 것 같다.
-----
## 날씨 데이터 수집 C. 데이터 가공 - 키 값 변경하기

- 주요 요구 사항 : 날씨 데이터 수집 B에서 얻는 결과를 활용하여, KEY 값들을 한글로 변경한 딕셔너리를 반환하도록 구성합니다.

- 결과 : $ python problem3.py
  ```
  {'기본': {'기압': 1004,
        '습도': 89,
        '온도': 299.11,
        '체감온도': 299.11,
        '최고온도': 299.81,
        '최저온도': 298.84},
  '날씨': [{'식별자': 501, '아이콘': '10n', '요약': 'moderate rain', '핵심': 'Rain'}]}
  ```

  - 기억해볼 부분
    ```python
    response_main['체감온도']=response_main.pop('feels_like')
    response_main['습도']=response_main.pop('humidity')
    response_main['기압']=response_main.pop('pressure')
    response_main['온도']=response_main.pop('temp')
    response_main['최고온도']=response_main.pop('temp_max')
    response_main['최저온도']=response_main.pop('temp_min')

    response_weather['요약']=response_weather.pop('description')
    response_weather['아이콘']=response_weather.pop('icon')
    response_weather['식별자']=response_weather.pop('id')
    response_weather['핵심']=response_weather.pop('main')
    ```
    - 딕셔너리의 키의 이름을 변경해주는 부분
    - 딕셔너리의 키의 이름을 변경할 때는 `dictionary.pop('name')`을 사용하여 변경해준다.

  - 트러블 슈팅한 부분
  
    ```python
    response_main['체감온도']=response_main.pop('feels_like')
    response_main['습도']=response_main.pop('humidity')
    response_main['기압']=response_main.pop('pressure')
    response_main['온도']=response_main.pop('temp')
    response_main['최고온도']=response_main.pop('temp_max')
    response_main['최저온도']=response_main.pop('temp_min')

    response_weather['요약']=response_weather.pop('description')
    response_weather['아이콘']=response_weather.pop('icon')
    response_weather['식별자']=response_weather.pop('id')
    response_weather['핵심']=response_weather.pop('main')
    ```
    - 트러블이라기보다는 헤맨 부분
    - 딕셔너리의 키 값을 일일이 다 변경해주었다.
      - 지금처럼 딕셔너리의 키 개수가 적을 때는 가능하지만 키의 개수가 방대해질 경우 이 방식은 불가능하다.
    - for문을 사용하여 좀 더 간편하게 이름을 바꿀 수 있을 것이다.
-----
## 날씨 데이터 수집 D. 데이터 가공 - 데이터 추가하기

- 주요 요구 사항 : 날씨 데이터 수집 C에서 얻는 결과를 활용하여, 섭씨온도 데이터를 추가합니다.
  - 온도, 체감온도, 최고온도, 최저온도에 대한 섭씨 온도 데이터를 추가

- 결과 : $ python problem4.py
  ```
  {'기본': {'기압': 1004,
        '습도': 89,
        '온도': 299.11,
        '온도 (섭씨)': 25.96,
        '체감온도': 299.11,
        '체감온도 (섭씨)': 25.96,
        '최고온도': 299.81,
        '최고온도 (섭씨)': 26.66,
        '최저온도': 298.84,
        '최저온도 (섭씨)': 25.69},
  '날씨': [{'식별자': 501, '아이콘': '10n', '요약': 'moderate rain', '핵심': 'Rain'}]}
  ```

  - 기억해볼 부분
    ```python
    def celsius(temp_cel):
    
    result0=float(temp_cel)-273.15

    result=float(format(result0, ".2f"))
    
    return result
    ```
    - 기억하기 보다는 나름 잘 한 부분
    - 섭씨 온도를 구하는 함수를 만들어서 간단하게 해결했다는 점이 
  - 트러블 슈팅한 부분
    - 특별히 트러블이 난 부분은 없다.
    - 그러나 앞에서 만든 내용을 활용할 때 매번 붙여넣기를 하는 것은 코드가 길어지면 쉽지 않기 때문에 모듈을 만들어서 사용하는 것도 나쁘지 않을 것 같다는 생각이 든다.
-----
## 날씨 데이터 수집 E. 생성형 AI 활용하기

- 주요 요구 사항 : 생성형 AI를 활용하여 자유롭게 데이터를 수집하고, 추출하고 가공해봅시다.

- 프롬프트 내용
  ```
  ### 페르소나
  - 당신은 사용자 질문에 답변하는 챗봇입니다.

  - 당신은 그 중에서도 세계 여러 도시의 날씨에 대해 대답하는 챗봇입니다.

  - 당신은 똑똑한 챗봇입니다. 어떤 질문에도 대답할 수 있습니다.

  ### 지침
  - 당신은 'OpenWeatherMap API'에서 정보를 찾아 사용자에게 적절한 날씨 정보를 제공해야 합니다.

  - 답변의 내용은 자유롭게 작성하되 기온, 날씨 상태에 대한 정보는 필수적으로 들어가야 합니다.

  - 답변은 사용자가 읽기 쉽도록 한국어로 번역을 해서 마크다운 형태로 정리해서 출력을 해주세요.

  지금부터 위의 내용을 지켜서 답변을 하도록 합니다.
  ```

- 결과:

  [ChatGPT 날씨 검색 프롬프트]('https://chatgpt.com/share/8991bd10-f6c0-4baa-a50f-5af3fe08aef7')
-----
## 금융 상품 데이터 수집 A. 데이터 추출 - KEY 값 출력하기

- 주요 요구 사항 : 전체 정기예금의 응답을 json 형태로 변환 후 Key 값만 출력하도록 구성합니다.

- 결과 : $ python problem1.py
  ```
  dict_keys(['prdt_div', 'total_count', 'max_page_no', 'now_page_no', 'err_cd', 'err_msg', 'baseList', 'optionList'])
  ```

  - 기억해볼 부분
    ```python
    _key = "cf41df1fc4bfeb53b668341ba71e0e85"

    url="http://finlife.fss.or.kr/finlifeapi/depositProductsSearch.json"
    params = {
        'auth' : api_key,
        # 금융회사 코드 020000(은행), 030200(여신전문), 030300(저축은행), 050000(보험), 060000(금융투자)
        'topFinGrpNo': '020000',
        'pageNo': 1
    }

    # 요구사항에 맞도록 이곳의 코드를 수정합니다.

    response=requests.get(url, params).json()
    ```
      - 날씨 데이터 수집과 달리 원하는 데이터를 요청하기 위해 url에 추가해야 하는 변수들이 많았다.
      - 해당 프로젝트에서는 많은 변수들을 하나의 딕셔너리로 만들어 최대한 간단하게 표현할 수 있도록 하였다는 점이 눈여겨 볼 만 하다.

  - 트러블 슈팅한 부분
    - 날씨 데이터 수집 A와 동일하다.
-----
## 금융 상품 데이터 수집 B. 데이터 추출 - 전체 정기예금 상품 리스트

- 주요 요구 사항 : 응답 중 정기예금 상품 리스트 정보만 출력하도록 합니다.
  - 정기예금 상품 리스트는 baseList에 들어 있다.

- 결과 : $ python problem2.py
  ```
  [{'dcls_end_day': None,
  'dcls_month': '202406',     
  'dcls_strt_day': '20240718',
  'etc_note': '- 가입기간: 1~36개월\n'
              '- 최소가입금액: 1만원 이상\n'
              '- 만기일을 일,월 단위로 자유롭게 선택 가능\n'
              '- 만기해지 시 신규일 당시 영업점과 인터넷 홈페이지에 고시된 계약기간별 금리 적용',
  'fin_co_no': '0010001',
  'fin_co_subm_day': '202407180943',
  'fin_prdt_cd': 'WR0001B',
  'fin_prdt_nm': 'WON플러스예금',
  'join_deny': '1',
  'join_member': '실명의 개인',
  'join_way': '인터넷,스마트폰,전화(텔레뱅킹)',
  'kor_co_nm': '우리은행',
  'max_limit': None,
  'mtrt_int': '만기 후\n'
              '- 1개월이내 : 만기시점약정이율×50%\n'
              '- 1개월초과 6개월이내: 만기시점약정이율×30%\n'
              '- 6개월초과 : 만기시점약정이율×20%\n'
              '\n'
              '※ 만기시점 약정이율 : 일반정기예금 금리',
  'spcl_cnd': '해당사항 없음'},
  {'dcls_end_day': '99991231',
  ...
  ```

  - 기억해볼 부분
      - 특별히 기억해 볼 부분이 있지 않았다.

  - 트러블 슈팅한 부분
    - 트러블도 크게 나지 않았다.
-----
## 금융 상품 데이터 수집 C. 데이터 가공 - 전체 정기예금 옵션 리스트

- 주요 요구 사항 : 응답 중 정기예금 상품들의 옵션 리스트를 출력하도록 구성합니다.
  - '금융상품코드', '저축 금리', '저축 기간', '저축금리유형' '저축금리유형명', '최고 우대금리' 데이터만 추출하여 출력한다.

- 결과 : $ python problem3.py
  ```
  [{'금융상품코드': 'WR0001B',
  '저축 금리': 3,
  '저축 기간': '1',
  '저축금리유형': 'S',
  '저축금리유형명': '단리',
  '최고 우대금리': 3},
  {'금융상품코드': 'WR0001B',
  '저축 금리': 3.45,
  '저축 기간': '3',
  '저축금리유형': 'S',
  '저축금리유형명': '단리',
  '최고 우대금리': 3.45},
  {'금융상품코드': 'WR0001B',
  '저축 금리': 3.45,
  ...
  ```

  - 기억해볼 부분
    ```python
    result=[]

    for i in range(len(result_optionList)):
        result_dict={}

        result_dict['금융상품코드']=result_optionList[i]['fin_prdt_cd']
        result_dict['저축 금리']=result_optionList[i]['intr_rate']
        result_dict['저축 기간']=result_optionList[i]['save_trm']
        result_dict['저축금리유형']=result_optionList[i]['intr_rate_type']
        result_dict['저축금리유형명']=result_optionList[i]['intr_rate_type_nm']
        result_dict['최고 우대금리']=result_optionList[i]['intr_rate2']

        result.append(result_dict)
    ```
      - 'optionList' 리스트 요소 하나하나에 대해서 해당 요소의 금융상품코드, 저축 금리, 저축 기간, 저축금리유형, 처죽금리유형명, 최고 우대금리를 모두 하나의 딕셔너리로 만들기 위해 for문을 썼다.
      - 만들어진 딕셔너리들은 하나의 리스트로 담기 위해 `list.append()`를 사용하여 새로운 리스트에 담아줬다.

  - 트러블 슈팅한 부분
    ```python
    result=[]

    for i in range(len(result_optionList)):
        result_dict={}

        result_dict['금융상품코드']=result_optionList[i]['fin_prdt_cd']
        result_dict['저축 금리']=result_optionList[i]['intr_rate']
        result_dict['저축 기간']=result_optionList[i]['save_trm']
        result_dict['저축금리유형']=result_optionList[i]['intr_rate_type']
        result_dict['저축금리유형명']=result_optionList[i]['intr_rate_type_nm']
        result_dict['최고 우대금리']=result_optionList[i]['intr_rate2']

        result.append(result_dict)
    ```
      - 분명 for문을 돌렸는데 optionList의 맨 마지막 요소에 대해서만 for문이 적용되어 해당 결과만 계속 반복되어 나타나는 오류가 발생했다.
      - 이는 처음에 result_dict를 for문 외부에서 선언했기 때문에 발생한 문제로 result_dict가 다른 요소에 대해 반복될 때마다 초기화가 되어서 새로운 딕셔너리로 만들어지고 그게 쌓여야 하는데 그러지 못하고 계속 덮어씌우기가 되었기 때문이다.
      - `result_dict={}`를 for문 가장 앞에서 선언해줌으로써 해결했다.
-----
## 금융 상품 데이터 수집 D. 데이터 가공 - 새로운 값을 만들어 반환하기

- 주요 요구 사항 : 상품과 옵션 정보들을 담고 있는 새로운 값을 만들어 딕셔너리 형태로 반환하도록 구성합니다.
  - 금융 상품: '금융회사명', '금융상품명', '금리정보'
  - 해당 금융 상품의 금리 정보(옵션): '저축금리유형', '저축금리유형명', '저축 기간', '저축 금리', '최고 우대금리'
  
- 결과 : $ python problem4.py
  ```
  [{'금리정보': [{'저축 금리': 3,
            '저축 기간': '1',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 3},
           {'저축 금리': 3.45,
            '저축 기간': '3',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 3.45},
           {'저축 금리': 3.45,
            '저축 기간': '6',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 3.45},
           {'저축 금리': 3.4,
            '저축 기간': '12',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 3.4},
           {'저축 금리': 2.95,
            '저축 기간': '24',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 2.95},
           {'저축 금리': 2.95,
            '저축 기간': '36',
            '저축금리유형': 'S',
            '저축금리유형명': '단리',
            '최고 우대금리': 2.95}],
  '금융상품명': 'WON플러스예금',
  '금융회사명': '우리은행'},
  {'금리정보': [{'저축 금리': 3,
  ...
  ```
  - 기억해볼 부분
    ```python
    for i in range(len(result_baseList)):
        result_dict_list=[]
        for j in range(len(result_optionList)):
            if result_baseList[i]['fin_prdt_cd']==result_optionList[j]['fin_prdt_cd']:
                result_dict_dict={}

                result_dict_dict['저축 금리']=result_optionList[j]['intr_rate']
                result_dict_dict['저축 기간']=result_optionList[j]['save_trm']
                result_dict_dict['저축금리유형']=result_optionList[j]['intr_rate_type']
                result_dict_dict['저축금리유형명']=result_optionList[j]['intr_rate_type_nm']
                result_dict_dict['최고 우대금리']=result_optionList[j]['intr_rate2']

                result_dict_list.append(result_dict_dict)

        result_dict={}    

        result_dict['금리정보']=result_dict_list
        result_dict['금융상품명']=result_baseList[i]['fin_prdt_nm']
        result_dict['금융회사명']=result_baseList[i]['kor_co_nm']

        result.append(result_dict)
    ```
      - C와 비슷하게 for문을 이용하여 새로운 리스트를 만들어줬다.
      - 하나의 금융상품에 대해 다양한 금리 정보가 존재할 수 있기 때문에 이중 for문을 사용하였다.
      - 'baseList'의 금융상품코드와 'optionList'의 금융상품코드가 같은 경우에만 넣을 수 있기 때문에 if문으로 그 유무를 먼저 확인한 후 원하는 값만을 딕셔너리에 집어넣어서 만들어주는 형식으로 접근했다.
        - 그렇게 만든 딕셔너리들은 리스트로 만들어서 하나로 묶어줬다.
      - 만들어진 리스트는 새로운 딕셔너리의 '금리정보' 키의 값으로 넣어주고 나머지 키의 값은 baseList의 요소들의 키의 값으로 넣어주었다.
      - 마지막으로 그렇게 만들어진 딕셔너리들을 최종 리스트에 넣어주었다.

  - 트러블 슈팅한 부분
    ```python
    for i in range(len(result_baseList)):
        result_dict_list=[]
        for j in range(len(result_optionList)):
            if result_baseList[i]['fin_prdt_cd']==result_optionList[j]['fin_prdt_cd']:
                result_dict_dict={}

                result_dict_dict['저축 금리']=result_optionList[j]['intr_rate']
                result_dict_dict['저축 기간']=result_optionList[j]['save_trm']
                result_dict_dict['저축금리유형']=result_optionList[j]['intr_rate_type']
                result_dict_dict['저축금리유형명']=result_optionList[j]['intr_rate_type_nm']
                result_dict_dict['최고 우대금리']=result_optionList[j]['intr_rate2']

                result_dict_list.append(result_dict_dict)

        result_dict={}    

        result_dict['금리정보']=result_dict_list
        result_dict['금융상품명']=result_baseList[i]['fin_prdt_nm']
        result_dict['금융회사명']=result_baseList[i]['kor_co_nm']

        result.append(result_dict)
    ```
      - 처음 발생한 오류는 출력값이 무한히 나오는 무한루프 현상이었다.
        - 모든 문장을 if문 안에 넣어주어서 발생한 오류이다.
        - `result_dict={} ~ result.append(result_dict)`까지의 문장을 if문 밖으로 빼줌으로서 해결했다.
      - 두번째로 발생한 오류는 출력값이 result_baseList의 마지막 요소에 대해서만 계속 반복이 되어서 나타나는 현상이었다.
        - result_dict_list를 바깥쪽 for문 안으로 넣어줌으로써 해결했다.
        - 또한`result_dict={} ~ result.append(result_dict)`까지의 문장을 안쪽 for문이 아닌 바깥쪽 for문 안으로 넣어줌으로써 해결했다.
-----
## 금융 상품 데이터 수집 E. 생성형 AI 활용하기

- 주요 요구 사항 : 생성형 AI를 활용하여 자유롭게 데이터를 수집하고, 추출하고 가공해봅시다.

- 프롬프트 내용
  ```
  ### 페르소나
  - 당신은 사용자 질문에 답변하는 챗봇입니다.

  - 당신은 그 중에서도 한국의 다양한 금융 상품에 대한 정보를 제공하는 챗봇입니다.

  - 당신은 똑똑한 챗봇입니다. 어떤 질문에도 대답할 수 있습니다.

  - 당신은 금융감독원의 직원이기 때문에 '금융상품통합비교공시 API' 정보를 얻을 수 있습니다.

  ### 지침
  - 당신은 '금융상품통합비교공시 API'에서 정보를 찾아 사용자에게 적절한 금융 상품 정보를 제공해야 합니다.

  - 답변의 내용은 자유롭게 작성하되 사용자가 읽기 쉽도록 마크다운 형태로 정리해서 출력을 해야합니다.

  지금부터 위의 내용을 지켜서 답변을 하도록 합니다.
  ```

- 결과:

  [ChatGPT 금융 정보 검색 프롬프트]('https://chatgpt.com/share/3d3d227a-42ee-4539-b4c3-d7b8306d10cb')

....

# 오늘 후기
- 생각보다 시간이 많이 걸렸지만 집에 가기 전에 주어진 모든 문제를 다 해결하고 갈 수 있어서 뿌듯했다.
- API라는 것을 이번에 처음 제대로 활용해봤는데 굉장히 유용하다고 느꼈고 파이썬으로 유용한 작동을 하는 무언가를 처음으로 만들어 본 기분이라 신기했다.
- ChatGPT 프롬프트 작성은 직접 파이썬을 이용해서 코드를 작성하고 파이썬 상에서 GPT API를 이용하여 챗봇을 만드는 과정인 줄 알았는데 그정도로 복잡한 것은 아니고 그냥 생성형 AI에게 입력할 내용들만 정하는 문제였다.
  - 이걸 좀 더 빨리 알았으면 훨씬 과제를 일찍 끝낼 수 있었을텐데 아쉽다.
- 이번 프로젝트 덕분에 함수를 선언하고 결과를 호출하는 과정, for문을 활용하는 방법에 대해서 더 익힐 수 있었다. 또한 복잡한 데이터를 읽고 분석하는 과정도 익힐 수 있었다.
  - 빅데이터 전문가 혹은 그낭 데이터 관련 전문가가 되고 싶은 나에게는 정말 유용하고 꼭 필요한 프로젝트였다고 생각한다.
- 중간 중간 에러가 발생하기도 했지만 몰입해서 고민하고 결국 해결하는 나 자신이 자랑스럽다. 박예승 화이팅.


### 참고 사이트

* [파이썬 공식 문서 dictionary 파트 중 key와 pop에 대한 설명](https://docs.python.org/ko/3/library/stdtypes.html#dict.keys)
