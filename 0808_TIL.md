# 문자열 수식 계산
- 스택을 이용하여 계산할 수 있다.

## 기본 방법
1. 중위 표기법의 수식을 후위 표기법으로 변경한다.
    - 중위 표기법(infix notation): 연산자를 피연산자의 가운데에 표기하는 방법
        - A+B
    - 후위 표기법(postfix notation): 연산자를 피연산자의 뒤에 표기하는 방법
        - AB+
2. 후위 표기법의 수식을 스택을 이용하여 계산한다.

## 중위 표기법의 수식을 후위 표기법으로 변경하기
### 기본적인 방법
1. 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
2. 각 연산자를 그에 대응하는 닫는 괄호의 뒤로 이동시키고 괄호를 제거
```
ex) 6+5*(2-8)/2

1단계. (6+((5*(2-8))/2))
2단계. (6((5(28)-)*2)/)+

결과. 6528-*2/+
```

### 스택을 이용한 변환 알고리즘
#### 알고리즘 개요
1. 입력 받은 중위 표기식에서 토큰(연산자 or 피연산자)을 읽는다.
2. 토큰이 피연산자일 경우 토큰을 출력한다.
3. 토큰이 연산자일 경우
    - 해당 연산자가 닫는 괄호를 제외한 나머지 연산자일 때
        - 스택의 top에 저장되어 있는 연산자보다 우선순위가 높을 경우 스택에 push
        - 그렇지 않을 경우 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지, 즉 push가 가능할 때까지 pop하고 push한다.
    - 해당 연산자가 닫는 괄호일 때
        - 스택의 top에 여는 괄호가 올 때까지 pop 연산을 수행하고 pop한 연산자는 출력한다.
        - 여는 괄호를 만나면 pop만 하고 출력하지는 않는다.
    - top에 연산자가 없을 경우 push한다.
4. 중위 표기식에 더 읽을 것이 없다면 중지하고 더 읽을 것이 있다면 1부터 다시 반복한다.
5. 스택에 남아 있는 연산자를 모두 pop하여 출력한다.

#### 연산자 우선순위
- 숫자가 높을수록 우선순위가 높다.

|토큰|스택의 밖에 있을 때|스택의 안에 있을 때|
|:----:|:----:|:----:|
|)|-|-|
|*, /|2|2|
|+, -|1|1|
|(|0|3|

- 여는 괄호의 경우 스택의 밖에 있을 때(push할 때)와 스택의 안에 있을 때(pop할 때)의 우선순위가 다르다.
    - 여는 괄호는 무조건 push하고 스택의 안에 있을 때는 닫는 괄호가 나오지 않는 이상 pop을 하지 않는다.
- 닫는 괄호는 우선순위와 상관 없이 움직이기 때문에 우선순위가 없다.
- 나머지 연산자의 우선순위는 우리가 사칙연산을 할 때 우선순위로 생각해주면 편할듯하다.

#### 그림으로 알아보기

**0단계**

![alt text](image-37.png)

기본 준비 상태. 연산자를 담을 스택과 후위표기법으로 입력되는 토큰을 담을 리스트가 필요하다.

**1단계**

![alt text](image-38.png)

여는 괄호는 스택 밖에 있을 때 우선순위가 제일 높으므로 무조건 push를 한다.

**2단계**

![alt text](image-39.png)

피연산자는 그대로 출력할 리스트에 담아준다.

**3단계**

![alt text](image-40.png)

여는 괄호는 스택 안에서 우선 순위가 가장 낮으므로 '+'를 push한다.

**4단계**

계속해서 피연산자는 출력, 연산자는 우선순위에 따른 push를 해준다. (사진 생략)

**5단계**

![alt text](image-42.png)

닫는 괄호가 나오면 여는 괄호를 만날 때까지 모두 pop하고 출력한다. 여는 괄호를 만나면 pop하고 출력은 하지 않는다. 동일하게 닫는 괄호도 출력하지 않는다.

**6단계**

![alt text](image-43.png)

'*'의 경우 '/'와 동일한 우선순위, 즉 낮지 않은 우선순위를 갖고 있기 때문에 pop하고 출력한다. 그 뒤의 '+'는 '/'보다 낮은 우선순위를 갖고 있기 때문에 push한다.

**7단계**

뒤의 과정도 동일한 규칙으로 반복해준다.

**8단계**

![alt text](image-44.png)

수식이 끝났을 경우 스택을 확인하여 스택이 비었다면 종료하고 후위표기법으로 나타낸 결과값을 얻는다.

#### 코드
```python
import sys

sys.stdin = open('input.txt')

def icp(oper):    # 스택 밖에 있을 때 우선순위를 지정하는 함수
    if oper == '(':
        return 3
    elif oper in ('*', '/'):
        return 2
    elif oper in ('+', '-'):
        return 1

def isp(oper):    # 스택 안에 있을 때 우선순위를 지정하는 함수
    if oper == '(':
        return 0
    elif oper in ('*', '/'):
        return 2
    elif oper in ('+', '-'):
        return 1

# Testcase 수
T = int(input())
# Testcase 만큼 반복
for tc in range(1, T+1):

    infix = list(input())
    stack = []
    top = -1
    postfix = []    # 후위표기법의 결과를 담는 리스트

    for token in infix:
        if token.isdecimal():    # 숫자면
            postfix.append(token)    # postfix에 append
        else:
            if not stack:    # 스택이 비어있으면
                top += 1
                stack.append(token)    # 무조건 push
            else:    # 스택이 채워져 있는데
                if token != ')':    # 닫는 괄호가 아니면
                    if isp(stack[top]) < icp(token):    # top에 있는 것보다 내 우선순위가 더 높으면
                        top += 1
                        stack.append(token)    # push
                    else:    # 그렇지 않으면
                        while isp(stack[top]) >= icp(token):    # 내 우선순위가 더 높아질 때까지
                            top -= 1
                            temp = stack.pop()
                            postfix.append(temp)    # top을 pop하고 pop한 걸 postfix에 append
                        top += 1
                        stack.append(token)    # 내 우선순위가 높아지면 push
                else:    # 닫는 괄호의 경우에는
                    while stack[top] != '(':    # 여는 괄호를 만날 때까지
                        top -= 1
                        temp = stack.pop()
                        postfix.append(temp)    # top을 pop하고 postfix에 append
                    top -= 1
                    stack.pop()    # 여는 괄호를 만나면 여는 괄호 pop만 하기

    while stack:    # 스택이 비어질 때까지
        temp = stack.pop()
        postfix.append(temp)    # 남아있는 애들을 모두 pop하고 postfix에 append

    print(f"#{tc} {''.join(postfix)}")
```

## 후위 표기법의 수식을 스택을 이용하여 계산하기
### 알고리즘 개요
1. 피연산자를 만나면 스택에 push한다.
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고 연산결과를 다시 스택에 push한다.
3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.

### 그림으로 알아보기
#### 1단계

![alt text](image-45.png)

피연산자를 만나면 스택에 push한다.

#### 2단계

![alt text](image-46.png)

연산자를 만나면 스택에서 피연산자를 두 번 pop한다. 이때 먼저 pop한 피연산자를 연산자의 오른쪽에, 나중에 pop한 피연산자를 연산자의 왼쪽에 놓고 계산한다. 계산한 결과는 다시 스택에 push한다.

#### 3단계

수식에 더 이상 토큰이 없을 때까지 반복한다. (사진 생략)

#### 4단계

![alt text](image-47.png)

수식에 더 이상 토큰이 없다면 스택에서 최종 결과값을 pop하여 출력한다.

### 코드
```python
def calculate():
    num2 = stack.pop()
    num1 = stack.pop()

    return num1, num2

postfix = ['6', '5', '2', '8', '-', '*', '2', '/', '+']
stack = []

for token in postfix:
    if token.isdecimal():
        stack.append(int(token))
    else:
        if token == '-':
            num1, num2 = calculate()
            temp = num1 - num2
            stack.append(temp)
        elif token == '+':
            num1, num2 = calculate()
            temp = num1 + num2
            stack.append(temp)
        elif token == '*':
            num1, num2 = calculate()
            temp = num1 * num2
            stack.append(temp)
        else:
            num1, num2 = calculate()
            temp = num1 / num2
            stack.append(temp)

result = stack.pop()
print(result)
```